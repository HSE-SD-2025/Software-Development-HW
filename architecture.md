### Архитектура библиотеки

1. Базовые классы:

   - **Graph:** Представляет собой абстракцию графа и содержит операции для добавления, удаления вершин и рёбер, а также методы предоставления структуры графа в нужной форме (например, списки смежности).
     
   - **GraphAlgorithm:** 
     - Абстрактный класс для всех алгоритмов, связанных с графами. Это базовый интерфейс для всех остальных алгоритмов.
     
2. Специализированные алгоритмы:

   - **SourceDestinationGraphAlgorithm:** 
     - Специализация для алгоритмов, работающих с заданными источником и назначением (например, Дейкстра).

   - **AllPairsGraphAlgorithm:** 
     - Специализация для алгоритмов, которые находят кратчайшие пути между всеми парами вершин (например, Флойд-Уоршалл).

   - **YenAlgorithm:** 
     - Специфическая реализация для поиска k кратчайших путей.

3. Конкретные реализации:

   Каждому алгоритму соответствует свой класс, наследующийся от одной из трех вышеупомянутых абстракций, реализующий детальную логику алгоритма:

   - От SourceDestinationGraphAlgorithm:
     - DijkstraAlgorithm
     - BellmanFordAlgorithm, и т.д.
     
   - От AllPairsGraphAlgorithm:
     - FloydWarshallAlgorithm, и др.

4. Утилиты и вспомогательные классы:

   - **GraphFactory:** 
     - Утилита для создания графов из различных источников (файлов, случайных данных).

   - **Path:** 
     - Структура, представляющая путь в графе, может включать лист вершин и суммарную стоимость.

### Экспериментальная среда

1. **ExperimentRunner:** 

   - Класс или набор классов, которые позволяют запускать алгоритмы на различных наборах входных данных и сравнивать их производительность и результативность.
   - Может включать методы:
     - runExperiment(const Graph& graph, GraphAlgorithm& algorithm): Запускает указанный алгоритм на заданном графе.
     - compareAlgorithms(const Graph& graph, const std::vector<GraphAlgorithm*>& algorithms): Сравнивает результаты и производительность нескольких алгоритмов на одном графе.

2. **ResultAnalyzer:** 

   - Модуль для сбора и анализа результатов экспериментов. Он может создавать отчеты об эффективности каждого алгоритма и визуализировать результаты (например, с использованием графиков).
