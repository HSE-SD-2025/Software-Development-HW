# Библиотека алгоритмов поиска кратчайших путей

Добро пожаловать в библиотеку алгоритмов поиска кратчайших путей. Эта библиотека предоставляет набор мощных алгоритмов для решения задачи поиска кратчайших путей в графах от заданной вершины до всех остальных.

## Содержание

- Введение
- Установка
- Использование
- Список алгоритмов
- Лицензия

## Введение

Эта библиотека предоставляет реализацию восьми различных алгоритмов поиска кратчайших путей. Вы можете выбрать наиболее подходящий алгоритм в зависимости от задачи и специфики графа — будь то граф с отрицательными весами, разреженный граф или что-то еще.

![Пример решения задачи с помощью алгоритма Дейкстры](resources/dijkstra_animation.gif)

## Установка

Склонируйте репозиторий и соберите проект с помощью CMake:
```
git clone git@github.com:HSE-SD-2025/Software-Development-HW.git
cd Software-Development-HW
mkdir build
cd build
cmake ..
make
```
## Использование

Основная библиотека располагает удобным интерфейсом для работы с различными алгоритмами. Пример:
```
#include "search_library.h"

int main() {
    // Выбираем алгоритм Дейкстры
    GraphAlgorithm algo = DijkstraAlgorithm()

    // Инициализация графа
    Graph graph = ...

    // Используем алгоритм
    Result result = algo.find_shortest_path(graph, start_vertex);

    // Обработка результата
    print_paths(result);

    return 0;
}
```

## Список алгоритмов

1. Алгоритм Дейкстры: Обеспечивает поиск кратчайшего пути в графах с неотрицательными весами.
2. Алгоритм Беллмана-Форда: Подходит для графов с прямо направленными рёбрами, включая отрицательные веса.
3. Полный перебор: Теоретический метод, применяемый для получения оптимального решения исчерпывающим образом.
4. Алгоритм A*: Эвристический метод, идеален для использования на сетках.
5. Алгоритм Джонсона: Находит кратчайшие пути между всеми парами вершин, поддерживая работу с отрицательными весами.
6. Алгоритм Левита: Применяется для задач, где важно оптимизировать поиск на направленных графах.
7. Двунаправленный алгоритм Дейкстры: Ускоряет решение задачи поиска между двумя вершинами за счет двунаправленного поиска.
8. Алгоритм Дейкстры с модификацией для разреженных: Эффективен на разреженных графах.

## Как расширять библиотеку?

В библиотеке есть абстрактный класс - ```GraphAlgorithm```, который имеет единственный метод -  ```std::vector<Vertex> find_shortest_path(const Graph& graph, const Vertex& start, const Vertex& end)```. Для добавления нового алгоритма в библиотеку достаточно просто отнаследоваться от этого класса.

## Сравнение по времени и памяти различных алгоритмов
Сравнение на графе из 7 вершин.
* Djikstra. Время: 7.8292e-05 seconds. Память: 1.3 Mib
* AStar. Время: 0.000194333 seconds. Память: 1.3 Mib
* BruteForce. Время: 3.0333e-05 seconds. Память: 1.2 Mib
* BellmanFord. Время: 0.00023275 seconds. Память: 1.3 Mib
* Johnson. Время: 0.000935292 seconds. Память: 1.3 Mib

Сравнение на графе из 30 вершин.
* Djikstra. Время: 0.000255083 seconds. Память: 2.8 Mib
* AStar. Время: 0.000396625 seconds. Память: 2.3 Mib
* BruteForce. Время: 0.000265375 seconds. Память: 2.3 Mib
* BellmanFord. Время: 0.00100925 seconds. Память: 2.8 Mib
* Johnson. Время: 0.0429215 seconds. Память: 3.0 Mib

## Лицензия

Проект распространяется под лицензией MIT. См. файл [`LICENSE`](LICENSE) для получения дополнительной информации.
